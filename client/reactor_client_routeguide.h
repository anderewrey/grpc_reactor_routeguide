///
/// SPDX-License-Identifier: Apache-2.0
/// Copyright 2024-2025 anderewrey
///

#pragma once

#include <grpcpp/client_context.h>

#include <memory>
#include <utility>

#include "generated/route_guide.pb.h"
#include "generated/route_guide.grpc.pb.h"

#include "client/reactor_client.h"

/************************
 * API: Following code belongs to the API implementation
 * That code could be auto-generated by jinja template files.
 ************************/
namespace routeguide {
enum class RpcMethods {
  kGetFeature,
  kListFeatures,
  kRecordRoute,
  kRouteChat,
  kRpcMethodsLast,
};
constexpr auto kRpcMethodsQty = static_cast<size_t>(RpcMethods::kRpcMethodsLast);
}

/************************
 * ClientReactor/GetFeature: Following code belongs to the API implementation
 * That code could be auto-generated by jinja template files (because of the stub.async()->rpc_method() call).
 ************************/
namespace routeguide::GetFeature {
using RequestT = routeguide::Point;     ///< Request message of RouteGuide::Getfeature RPC
using ResponseT = routeguide::Feature;  ///< Response message of RouteGuide::Getfeature RPC
inline constexpr auto RpcKey = routeguide::RpcMethods::kGetFeature;  ///< RPC identifier of RouteGuide::Getfeature
/// Specialized reactor class for RouteGuide::Getfeature unary RPC client
class ClientReactor final : public RpcReactor::Client::ProxyUnaryReactor<ResponseT> {
 public:
  /// Constructor of the specialized class. It calls the RPC method with the address pointer where
  /// the response is wanted to be written. The context and the callbacks objects are moved to the
  /// underlying generic class.
  /// @param stub of the RouteGuide API
  /// @param context given to the reactor and is associated with the called RPC method
  /// @param request to send to the server
  /// @param cbs given to the reactor to be used as callable functions
  ClientReactor(RouteGuide::Stub& stub,
                std::unique_ptr<grpc::ClientContext> context,
                const RequestT& request,
                callbacks&& cbs)
      : ProxyUnaryReactor(std::move(context), std::move(cbs)) {
    // (Point 1.2, 1.3) async RPC call
    stub.async()->GetFeature(context_.get(), &request, &response_, this);
    // (Point 1.4, 1.5) Starting RPC call, send request to server
    StartCall();
  }
};
}  // namespace routeguide::GetFeature

/************************
 * ClientReactor/ListFeatures: Following code belongs to the API implementation
 * That code could be auto-generated by jinja template files (because of the stub.async()->rpc_method() call).
 ************************/
namespace routeguide::ListFeatures {
using RequestT = routeguide::Rectangle;  ///< Request message of RouteGuide::ListFeatures RPC
using ResponseT = routeguide::Feature;   ///< Response message of RouteGuide::ListFeatures RPC
inline constexpr auto RpcKey = routeguide::RpcMethods::kListFeatures;  ///< RPC identifier of RouteGuide::ListFeatures
/// Specialized reactor class for RouteGuide::ListFeatures stream-reader RPC client
class ClientReactor final : public RpcReactor::Client::ProxyReadReactor<ResponseT> {
 public:
  /// Constructor of the specialized class. It calls the RPC method and start the stream reading
  /// with the address pointer where the response is wanted to be written.
  /// @param stub of the RouteGuide API
  /// @param context given to the reactor and is associated with the called RPC method
  /// @param request to send to the server
  /// @param cbs given to the reactor to be used as callable functions
  ClientReactor(RouteGuide::Stub& stub,
                std::unique_ptr<grpc::ClientContext> context,
                const RequestT& request,
                callbacks&& cbs)
      : ProxyReadReactor(std::move(context), std::move(cbs)) {
    // (Point 1.2, 1.3) async RPC call
    stub.async()->ListFeatures(context_.get(), &request, this);
    // (Point 1.4) Starting reading
    StartRead(&response_);
    // (Point 1.5, 1.6) Starting RPC call, send request to server
    StartCall();
  }
};
}  // namespace routeguide::ListFeatures
